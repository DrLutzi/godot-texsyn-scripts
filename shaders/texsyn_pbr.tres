[gd_resource type="Shader" format=2]

[resource]
code = "shader_type spatial;

uniform sampler2DArray samplerExemplar;
uniform sampler2DArray samplerExemplar1DFormat;
uniform float tilingScale;
uniform bool enableIsotropy;
uniform bool enableSymmetry;
uniform float isotropyStartAngle;
uniform float isotropyEndAngle;
uniform bool debug_showTiling;

const float PI = 3.14159265359;

float rnd21(vec2 p)
{
	return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec2 rnd22(vec2 p)
{
	return fract(sin(p * mat2(vec2(127.1, 311.7), vec2(269.5, 183.3)) ) * 43758.5453);
}

vec3 srgb2rgb(vec3 C)
{
//	return pow( max(C, 0.), vec3( 2.2 )  );
	return C;
}

vec3 rgb2srgb(vec3 C)
{
//	return pow( max(C, 0.), vec3(1./2.2) );
	return C;
}

float W0cos(vec2 uv)
{
	float cosu = sin(uv.x*PI);
	float cosv = sin(uv.y*PI);
	return pow(cosu*cosv*cosu*cosv, 0.5)+0.01;
}

float W1cos(vec2 uv)
{
	uv.x+=0.5;
	uv.y+=0.5;
	float cosu = sin(uv.x*PI);
	float cosv = sin(uv.y*PI);
	return pow(cosu*cosv*cosu*cosv, 0.5)+0.01;
}

vec2 K0(vec2 uv)
{
	vec2 seed;
	seed.x = floor(uv.x);
	seed.y = floor(uv.y);
	return seed*2.0;
}

vec2 K1(vec2 uv)
{
	vec2 seed;
	seed = vec2(floor(uv.x+0.5), floor(uv.y+0.5));
	return seed*2.0 + vec2(1.0, 1.0);
}

vec2 rotateRandom(vec2 k, vec2 uv)
{
	vec2 r = rnd22(k);
	float a = fract(r.x+r.y)*(isotropyEndAngle-isotropyStartAngle) + isotropyStartAngle;
	float cosA = cos(a);
	float sinA = sin(a);
	mat2 rotateA = mat2(vec2(cosA, sinA), vec2(-sinA, cosA));
	return rotateA*uv;
}

vec2 reflectRandom(vec2 k, vec2 uv)
{
	float r = (round(rnd21(k))-0.5)*2.0;
	return mat2(vec2(1, 0), vec2(0, r))*uv;
}

vec3 tilingContent(in vec2 k, in vec2 uv, in vec3 m, vec2 Gx, vec2 Gy, float index)
{
	vec2 transformedUV = uv - rnd22(k);
	if(enableIsotropy)
	{
		transformedUV = rotateRandom(k, transformedUV);
	}
	if(enableSymmetry)
	{
		transformedUV = reflectRandom(k, transformedUV);
		Gx = dFdx(transformedUV); //when using symmetry Gx and Gy must be recomputed
		Gy = dFdy(transformedUV);
	}
	return srgb2rgb(textureGrad(samplerExemplar, vec3(transformedUV, index), Gx, Gy).rgb - m);
}

float tilingContent1D(in vec2 k, in vec2 uv, in float m, vec2 Gx, vec2 Gy, float index)
{
	vec2 transformedUV = uv - rnd22(k);
	if(enableIsotropy)
	{
		transformedUV = rotateRandom(k, transformedUV);
	}
	if(enableSymmetry)
	{
		transformedUV = reflectRandom(k, transformedUV);
		Gx = dFdx(transformedUV); //when using symmetry Gx and Gy must be recomputed
		Gy = dFdy(transformedUV);
	}
	return textureGrad(samplerExemplar1DFormat, vec3(transformedUV, index), Gx, Gy).x - m;
}

void vertex() 
{}

void fragment() 
{
	vec3 meanAlbedo = srgb2rgb( texture(samplerExemplar, vec3(UV, 0), 99.).xyz);	// mean texture albedo
	vec3 meanNormal = srgb2rgb( texture(samplerExemplar, vec3(UV, 1), 99.).xyz);	// mean texture normal
	float meanDepth = texture(samplerExemplar1DFormat, vec3(UV, 0), 99.).x;	// mean texture depth
	float meanRoughness = texture(samplerExemplar1DFormat, vec3(UV, 1), 99.).x;	// mean texture depth
	float meanMetallic = texture(samplerExemplar1DFormat, vec3(UV, 2), 99.).x;	// mean texture depth
	float meanAO = texture(samplerExemplar1DFormat, vec3(UV, 3), 99.).x;	// mean texture depth
	vec2 UVScaled = UV/tilingScale;									// scale of the synthesis
	vec2 Gx, Gy;
	if(!enableSymmetry)
	{
		Gx = dFdx(UVScaled);									//coordinate derivatives
		Gy = dFdy(UVScaled);
	}
	vec3 w;														//weights
	float wSum;													//weights sum
	vec2 k0 = K0(UVScaled);										//first tiling
	vec2 k1 = K1(UVScaled);										//second tiling
	w = vec3(W0cos(UVScaled), W1cos(UVScaled), 0.0);
	wSum = w.x+w.y+w.z;
	w/=wSum;
	if(debug_showTiling)
	{
		ALBEDO = vec3(cos(k0.x*PI), cos(k0.y*PI), 1.0);
	}
	else
	{
		ALBEDO = tilingContent(k0, UVScaled, meanAlbedo, Gx, Gy, 0.0)*w.x 
				+ tilingContent(k1, UVScaled, meanAlbedo, Gx, Gy, 0.0)*w.y;
		ALBEDO = meanAlbedo + ALBEDO/length(w);  // contrast preserving interp. cf https://www.shadertoy.com/view/4dcSDr
		NORMALMAP = tilingContent(k0, UVScaled, meanNormal, Gx, Gy, 1.0)*w.x 
					+ tilingContent(k1, UVScaled, meanNormal, Gx, Gy, 1.0)*w.y;
		NORMALMAP = normalize(meanNormal + NORMALMAP/length(w));  // contrast preserving interp. cf https://www.shadertoy.com/view/4dcSDr
		DEPTH = tilingContent1D(k0, UVScaled, meanDepth, Gx, Gy, 0.0)*w.x 
				+ tilingContent1D(k1, UVScaled, meanDepth, Gx, Gy, 0.0)*w.y;
		DEPTH = clamp(meanDepth + DEPTH/length(w), 0., 1.);
		ROUGHNESS = tilingContent1D(k0, UVScaled, meanRoughness, Gx, Gy, 1.0)*w.x 
				+ tilingContent1D(k1, UVScaled, meanRoughness, Gx, Gy, 1.0)*w.y;
		ROUGHNESS = clamp(meanRoughness + ROUGHNESS/length(w), 0., 1.);
		METALLIC = tilingContent1D(k0, UVScaled, meanMetallic, Gx, Gy, 2.0)*w.x 
				+ tilingContent1D(k1, UVScaled, meanMetallic, Gx, Gy, 2.0)*w.y;
		METALLIC = clamp(meanDepth + METALLIC/length(w), 0., 1.);
		AO = tilingContent1D(k0, UVScaled, meanAO, Gx, Gy, 3.0)*w.x 
				+ tilingContent1D(k1, UVScaled, meanAO, Gx, Gy, 3.0)*w.y;
		AO = clamp(meanAO + AO/length(w), 0., 1.);
	}
	ALBEDO = clamp( rgb2srgb(ALBEDO), 0., 1.);
}"
